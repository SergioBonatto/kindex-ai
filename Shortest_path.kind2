// -- boilerplate --
// idxval : ‚àÄ {n : ‚Ñï} ‚Üí idx n ‚Üí ‚Ñï
// idxval Z = 0
// idxval (S i) = 1 + idxval i
IdxVal <n : Data.Nat> (idx: Data.Fin n)       : Data.Nat
IdxVal (Data.Nat.zero)   (idx)                = Data.Nat.zero
IdxVal (Data.Nat.succ n) (Data.Fin.zero)      = Data.Nat.zero
IdxVal (Data.Nat.succ n) (Data.Fin.succ idx)  = Data.Nat.succ (IdxVal n idx)

// lemma1 : ‚àÄ (n : ‚Ñï) ‚Üí n <? S n ‚â° [<]
// lemma1 Z = ‚ÜØ
// lemma1 (S n) = lemma1 n
Lemma1 (n: Data.Nat)      : Prop.Equal (Data.Nat.ltn n (Data.Nat.succ n)) Data.Bool.true
Lemma1 Data.Nat.zero      = Prop.Equal.refl
Lemma1 (Data.Nat.succ n)  = Lemma1 n

// lemma2 : ‚àÄ (n : ‚Ñï) ‚Üí ‚àÄ (i : idx n) ‚Üí idxval i <? S n ‚â° [<]
// lemma2 (S x) Z = ‚ÜØ
// lemma2 (S x) (S i) = lemma2 x i
// #partial
Lemma2 <n: Data.Nat> (i: Data.Fin n)        : Prop.Equal (Data.Nat.ltn (IdxVal n i) (Data.Nat.succ n)) Data.Bool.true
Lemma2 Data.Nat.zero i                      = Data.Empty.absurd (Data.Fin.absurd i)
Lemma2 (Data.Nat.succ x) Data.Fin.zero      = Prop.Equal.refl
Lemma2 (Data.Nat.succ x) (Data.Fin.succ i)  = Lemma2 x i

// lemma3 : ‚àÄ (n : ‚Ñï) ‚Üí ‚àÄ (i : idx n) ‚Üí idxval i <? n ‚â° [<]
// lemma3 Z ()
// lemma3 (S n) Z = ‚ÜØ
// lemma3 (S n) (S i) = lemma3 n i
Lemma3 <n: Data.Nat> (i: Data.Fin n)        : Prop.Equal (Data.Nat.ltn (IdxVal n i) n) Data.Bool.true
Lemma3 Data.Nat.zero i                      = Data.Empty.absurd (Data.Fin.absurd i)
Lemma3 (Data.Nat.succ n) Data.Fin.zero      = Zero_lte_n n
Lemma3 (Data.Nat.succ n) (Data.Fin.succ i)  = Lemma3 n i

Zero_lte_n (n: Data.Nat)      : Prop.Equal (Data.Nat.lte Data.Nat.zero n) Data.Bool.true
Zero_lte_n Data.Nat.zero      = Prop.Equal.refl
Zero_lte_n (Data.Nat.succ n)  = Prop.Equal.refl

// neighbors : ‚àÄ {n : ‚Ñï} ‚Üí vec[ S n ] ùîπ ‚Üí list (idx (S n))
// neighbors {n} v = neighbors' v (ùïö n {S n} {{lemma1 n}}) []
Neighbors 
  <n: Data.Nat> 
  (v: Data.Vector Data.Bool (Data.Nat.succ n)) 
  : Data.List (Data.Fin (Data.Nat.succ n))
Neighbors Data.Nat.zero v      = Neighbors_                0n v (Data.Fin.zero) (Data.List.nil)
Neighbors (Data.Nat.succ n) v  = Neighbors_ (Data.Nat.succ n) v (Data.Fin.zero) (Data.List.nil)

//   where
//   reduce : ‚àÄ {n : ‚Ñï} ‚Üí idx (S n) ‚Üí idx (S n)
//   reduce Z = Z
//   reduce {n} (S Z) = (ùïö Z {S n})
//   reduce {n} (S m) = (ùïö (idxval m) {S n} {{lemma2 n m}})
Reduce <n: Data.Nat> (m: Data.Fin (Data.Nat.succ n))  : Data.Fin (Data.Nat.succ n)
Reduce Data.Nat.zero m                                = m
Reduce (Data.Nat.succ n) (Data.Fin.zero)              = Data.Fin.succ (Data.Fin.zero)
Reduce (Data.Nat.succ n) (Data.Fin.succ m)            = Data.Fin.succ (Reduce n m)
//
// Reduce <n: Data.Nat> (m: Data.Fin (Data.Nat.succ n))  : Data.Fin (Data.Nat.succ n)
// Reduce n Data.Fin.zero                                = Data.Fin.zero
// Reduce n (Data.Fin.succ Data.Fin.zero)                = Data.Fin.zero
// Reduce n (Data.Fin.succ m)                            =
//   // let lem = Lemma2 n m
//   let idx = IdxVal n m
//   let le1 = Lemma1 n
//   let le2 = Lemma2 n m
//   let le3 = Lemma3 n m
//
//   // ?
//   Data.Fin.succ (Data.Nat.to_fin (IdxVal n m))
//
//

// reduce : (n : Nat) -> Idx (S n) -> Idx (S n)
// reduce Z Z = Z
// reduce {n = n} (S Z) = Z
// reduce {n = n} (S m) = idxval m

//   neighbors' : ‚àÄ {n : ‚Ñï} ‚Üí vec[ S n ] ùîπ ‚Üí idx (S n) ‚Üí list (idx (S n)) ‚Üí list (idx (S n))
//   neighbors' v Z l with v #[ Z ]
//   ‚Ä¶ | I = Z ‚à∑ l
//   ‚Ä¶ | O = l
//   neighbors' {n} v m l with v #[ m ]
//   ‚Ä¶ | I = neighbors' v (reduce m) (m ‚à∑ l)
//   ‚Ä¶ | O = neighbors' v (reduce m) l
Neighbors_ 
  (n: Data.Nat)
  (v: Data.Vector Data.Bool (Data.Nat.succ n)) 
  (f: Data.Fin (Data.Nat.succ n)) 
  (l: Data.List (Data.Fin (Data.Nat.succ n))) 
  : Data.List (Data.Fin (Data.Nat.succ n))
Neighbors_ Data.Nat.zero (Data.Vector.cons a b c) Data.Fin.zero l = 
  Data.Bool.if (b) (Data.List.cons Data.Fin.zero l) l
Neighbors_ (n) v f l = 
  let b = Bool.vector n v
  let c = Neighbors_ n v (Reduce n f) (Data.List.cons f l)
  let d = Neighbors_ n v (Reduce n f) l
  Data.Bool.if b c d

#partial
Bool.vector (n: Data.Nat) (v: Data.Vector Data.Bool (Data.Nat.succ n)) : Data.Bool 
Bool.vector n (Data.Vector.cons a b c) = b

// lookup : ‚àÄ {n : ‚Ñï} ‚Üí idx n ‚Üí list (idx n) ‚Üí ùîπ
// lookup x [] = O
// lookup x (y ‚à∑ ys) with idxval x ‚â°? idxval y
// ‚Ä¶ | I = I
// ‚Ä¶ | O = lookup x ys
Lookup <n: Data.Nat> (x: Data.Fin n) (l: Data.List (Data.Fin n)) : Data.Bool
Lookup x Data.List.nil = Data.Bool.false
Lookup x (Data.List.cons (Data.Fin n) y ys) =
  let b = Data.Nat.equal (IdxVal n x) (IdxVal n y)
  let c = Lookup n x ys
  Data.Bool.if b Data.Bool.true c

// filter-list : ‚àÄ {n : ‚Ñï} ‚Üí list (idx n) ‚Üí list (idx n) ‚Üí list (idx n)
// filter-list [] ys = []
// filter-list (x ‚à∑ xs) ys with lookup x ys
// ‚Ä¶ | I = filter-list xs ys
// ‚Ä¶ | O = x ‚à∑ filter-list xs ys

Filter_list <n: Data.Nat> (xs: Data.List (Data.Fin n)) (ys: Data.List (Data.Fin n)) : Data.List (Data.Fin n)
Filter_list Data.List.nil ys = Data.List.nil
Filter_list (Data.List.cons (Data.Fin n) x xs) ys =
  let b = Lookup n x ys
  let c = Filter_list n xs ys
  Data.Bool.if b c (Data.List.cons (Data.Fin n) x (Filter_list n xs ys))


type Matrix (t: Type) {  
  nil
  cons (row: Data.List t) (xs: Matrix t) 
}

List.replicate <t> (n: Data.Nat) (x: t)  : Data.List t
List.replicate  t  Data.Nat.zero x       = Data.List.nil
List.replicate  t (Data.Nat.succ n) x    = Data.List.cons x (List.replicate n x)

// Graph.mk is a function that recives two nat, one to rows and other to columns, a type and return a Graph 
Matrix.create <t> <a> (rows: Data.Nat) (cols: Data.Nat) (v: a)(f: a -> t) : Matrix a
Matrix.create t a Data.Nat.zero cols v f = Matrix.nil :: Matrix a
Matrix.create t a (Data.Nat.succ rows) cols v f =
  let ind = Matrix.create t a rows cols v f
  let row = List.replicate cols v
  Matrix.cons row ind 

type Graph <t> {
  nil
  new <n: Data.Nat> (edge: Data.List (Data.Pair (Data.Fin n) (Data.List t))) 
} 

Data.Nat.to_fin (n: Data.Nat)     : Data.Fin (Data.Nat.succ n)
Data.Nat.to_fin Data.Nat.zero     = Data.Fin.zero
Data.Nat.to_fin (Data.Nat.succ n) = Data.Fin.succ (Data.Nat.to_fin n)

// (Data.Pair Data.U60 (Data.Pair Data.U60 Data.U60))
// Function to add an edge to graph
Graph.addedge (g: Graph) (p: Data.Pair Data.U60 Data.U60) : Graph
Graph.addedge Graph.nil p     =
  let e = Data.U60.to_nat (Data.Pair.fst p)
  let f = Data.Nat.to_fin e
  let g = Data.Fin.succ f
  Graph.new [(Data.Pair.new (g) ([(Data.Pair.snd p)]))]
Graph.addedge (Graph.new e) p =
  let e = Data.U60.to_nat (Data.Pair.fst p)
  let f = Data.Nat.to_fin e
  let g = Data.Fin.succ f
  Graph.new (Graph.update (Data.List.cons (Data.Pair.new (g) ([(Data.Pair.snd p)])) []) p)
  
Graph.update
  <t>
  <n: Data.Nat>
  (edge: Data.List (Data.Pair (Data.Fin (n)) (Data.List t)))
  (p: Data.Pair Data.U60 t)
  : (Data.List (Data.Pair (Data.Fin n) (Data.List t)))
Graph.update Data.List.nil p = Data.List.nil
Graph.update (Data.List.cons (Data.Pair (Data.Fin n) (Data.List t)) (Data.Pair.new fst Data.List.nil) xs.t) (Data.Pair.new  trd fth) =
  Data.List.cons (Data.Pair.new fst [fth]) Data.List.nil
Graph.update (Data.List.cons (Data.Pair (Data.Fin n) (Data.List t)) (Data.Pair.new (Data.Fin a) (Data.List b) fst (Data.List.cons ct xs.h xs.t)) xs.t.t) (Data.Pair.new a_ b_ trd fth) =
  let e = Data.Fin.to_nat fst
  let f = Data.Nat.to_u60 e
  let cond = Data.U60.to_bool (== f trd)
  if cond {
    Data.List.cons (Data.Pair.new fst (Data.List.cons fth Data.List.nil)) xs.t.t
  } else {
    let ind = Graph.update xs.t.t (Data.Pair.new trd fth)
    let head = Data.Pair.new fst (Data.List.cons xs.h xs.t)
    Data.List.cons head ind
  }

// Graph.update.godown
//   (cond: Data.U60)
//   (edge: Data.List (Data.Pair Data.U60 (Data.List Data.U60)))
//   (p: Data.Pair Data.U60 Data.U60)
//   : (Data.List (Data.Pair Data.U60 (Data.List Data.U60)))
// Graph.update.godown cond Data.List.nil p = Data.List.nil
// Graph.update.godown 0 (Data.List.cons xs.h xs.t) p = Data.List.cons xs.h (Graph.update xs.t p)
// Graph.update.godown n (Data.List.cons (Data.Pair t (Data.List c)) ((Data.Pair.new xs.h xs.t)) xs.t.t) (Data.Pair.new fst snd) =
//   Data.List.cons (Data.Pair.new xs.h (Data.List.cons snd xs.t)) xs.t.t

Graph.adjacent.vertices
  <t>
  <m: Data.Nat>
  (n: Data.U60)
  (edge: Data.List (Data.Pair (Data.Fin m) (Data.List t)))
  : Data.List t
Graph.adjacent.vertices n Data.List.nil = Data.List.nil
Graph.adjacent.vertices n (Data.List.cons (Data.Pair (Data.Fin m) (Data.List t)) (Data.Pair.new fst Data.List.nil) xs.t) =
  let fst0 = Data.Fin.to_nat fst
  let fst1 = Data.Nat.to_u60 fst0
  if (Data.U60.to_bool (== n fst1)) {
    Data.List.nil
  } else {
    Graph.adjacent.vertices n xs.t
  }
Graph.adjacent.vertices n (Data.List.cons (Data.Pair (Data.Fin m) (Data.List t)) (Data.Pair.new (Data.Fin a) (Data.List b) fst (Data.List.cons ct xs.h xs.t)) xs.t.t) =
  let fst0 = Data.Fin.to_nat fst
  let fst1 = Data.Nat.to_u60 fst0
  if (Data.U60.to_bool (== n fst1)) {
    xs.t
  } else {
    Graph.adjacent.vertices n xs.t.t
  } 
  
// // Graph.addedge (g: Graph) (p: Data.Pair Data.U60 Data.U60) : Graph
// // Graph.addedge (Graph.new e) (Data.Pair.new fst snd) = Graph.new ( Data.List.cons (Data.Pair.new fst (Data.List.cons snd (GetAdjacentVertices fst e))) e)
// //  -- Helper function to get the adjacent vertices of a vertex
// // #partial
// Get.adjacent (n: Data.U60) (g: Graph) : Data.List Data.U60
// Get.adjacent n (Graph.nil) = Data.List.nil
// Get.adjacent n (Graph.new Data.List.nil) = Graph.adjacent.vertices n Data.List.nil
// Get.adjacent n (Graph.new (Data.List.cons xs.h xs.t)) = Graph.adjacent.vertices n (Data.List.cons xs.h xs.t)
// #partial
Get.adjacent <t> (n: Data.U60) (g: Graph) : Data.List t
Get.adjacent t n (Graph.new Data.List.nil)  = Data.List.nil
Get.adjacent t n Graph.nil                  = Data.List.nil
Get.adjacent t n (Graph.new (Data.List.cons (Data.Pair (Data.Fin m) (Data.List t_)) (Data.Pair.new fst Data.List.nil) xs.t)) =
  let fst0 = Data.Fin.to_nat fst
  let fst1 = Data.Nat.to_u60 fst0
  if (Data.U60.to_bool (== n fst1)) {
    Data.List.nil
  } else {
    Get.adjacent n (Graph.new xs.t)
  }
Get.adjacent t n (Graph.new (Data.List.cons (Data.Pair (Data.Fin m) (Data.List t_)) (Data.Pair.new (Data.Fin o) (Data.List tz) fst (Data.List.cons ty ys.h ys.t)) xs.t)) =
  let fst0 = Data.Fin.to_nat fst
  let fst1 = Data.Nat.to_u60 fst0
  if (Data.U60.to_bool (== n fst1)) {
    Data.List.nil //(Data.List.cons ys.h ys.t) FIXME: this is wrong
  } else {
    Get.adjacent n (Graph.new xs.t)
    
  }

// // {-- BFS Traverse : returns list of nodes ordered by first seen to last --}
// // --------------------------------------------------------------------------
// // {-# TERMINATING #-}
// // bfs-traverse : ‚àÄ {n : ‚Ñï} ‚Üí graph[ S n ] ‚Üí idx (S n) ‚Üí list (idx (S n))
// // bfs-traverse G Œπ‚ÇÄ = bfs-traverse' G [ Œπ‚ÇÄ ] [] [ Œπ‚ÇÄ ]
Bfs_traverse (n: Data.Nat) (g: Graph) (i: Data.Fin n) : Data.List (Data.Fin n)
Bfs_traverse n g i = Bfs_traverse_ n g [i] []

// //   where
// //   bfs-traverse' :
// //     ‚àÄ {n : ‚Ñï}
// //     ‚Üí graph[ S n ]                         -- G: graph represented as adjacency matrix
// //     ‚Üí list (idx (S n)) ‚Üí list (idx (S n))  -- Q: processing queue, L: search result list
// //     ‚Üí list (idx (S n))                     -- œÉ: seen list to avoid cycles
    // ‚Üí list (idx (S n))
Bfs_traverse_
  (n: Data.Nat)
  (g: Graph)
  (q: Data.List (Data.Fin n))
  (s: Data.List (Data.Fin n))
  : Data.List (Data.Fin n)
Bfs_traverse_ n g Data.List.nil s = Data.List.reverse s
Bfs_traverse_ n g (Data.List.cons (Data.Fin m) xs.h xs.t) s =
  let h = Data.Fin.to_nat xs.h
  let h1 = Data.Nat.to_u60 h
  let neighbors = Get.adjacent h1 g
  let visited = Data.List.cons xs.h s
  let new = FilterList (y => NotElem y visited) neighbors
  let q = Data.List.concat xs.t new
  Bfs_traverse_ n g q visited



NotElem <n: Data.Nat> (x: Data.Fin n) (xs: Data.List (Data.Fin n)) : Data.Bool
NotElem x Data.List.nil                 = Data.Bool.true
NotElem x (Data.List.cons xs.h xs.t)    = 
  let x1  = Data.Fin.to_nat x
  let xh1 = Data.Fin.to_nat xs.h
  if (Data.Nat.equal x1 xh1) {
    Data.Bool.false
  } else {
    NotElem x xs.t
  }

FilterList <t> (f: t -> Data.Bool) (l: Data.List t) : Data.List t
FilterList t f Data.List.nil = Data.List.nil
FilterList t f (Data.List.cons xs.h xs.t) = if (f xs.h) {
  Data.List.cons xs.h (FilterList f xs.t)
} else {
  FilterList f xs.t
}
//
//
//
// // bfs : ‚àÄ {n : ‚Ñï} ‚Üí graph[ S n ] ‚Üí idx (S n) ‚Üí idx (S n) ‚Üí list ‚Ñï
// // bfs {n} G Œπ‚ÇÄ Œπ‚ÇÅ = let prev = bfs' G Œπ‚ÇÄ Œπ‚ÇÅ [ Œπ‚ÇÄ ] [ Œπ‚ÇÄ ] (const[vec]< S n > Œπ‚ÇÅ)
// //                   in return-path prev Œπ‚ÇÅ []
// Bfs (g: Graph) (i0: Data.U60) (i1: Data.U60) : Data.List Data.U60
// Bfs g i0 i1 =
//   // let prev = Bfs_ g i0 i1 [i0] [i0] (Const i1 Data.Nat.zero)
//   // ReturnPath prev i1 []
Bfs <n: Data.Nat> (g: Graph) (f1: Data.Fin n) (f2: Data.Fin n) : Data.List Data.Nat
// Bfs n g f1 f2 =
  // let prev = Bfs_ n g f1 f2 [f1] [f1] (Const f2 Data.Nat.zero)
  // ?



//
Const <a> <t> (x: a) (y: t) : a
Const x y = x
//
//  // return-path : vec[ S n ] (idx (S n)) ‚Üí idx (S n) ‚Üí list ‚Ñï ‚Üí list ‚Ñï
//  //  return-path prev Œπ res with idxval(prev #[ Œπ ]) ‚â°? idxval Œπ‚ÇÅ
//  //  ‚Ä¶ | O = return-path prev (prev #[ Œπ ]) (idxval (prev #[ Œπ ]) ‚à∑ res)
//  //  ‚Ä¶ | I with idxval Œπ‚ÇÄ ‚â°? idxval Œπ‚ÇÅ | res
//  //  ‚Ä¶ | O | [] = res                        -- path to node does not exist
//  //  ‚Ä¶ | O | xs = res ‚ß∫ [ idxval Œπ‚ÇÅ ]        -- path found from Œπ‚ÇÄ to Œπ‚ÇÅ
//   // ‚Ä¶ | I | _ = res ‚ß∫ [ idxval Œπ‚ÇÅ ]         -- path found, search for self
//  //
// ReturnPath
//   (n: Data.Nat)
//   (v: Data.Vector (Data.Fin (Data.Nat.succ n)) (Data.Nat.succ n))
//   (l: Data.List Data.Nat)
//   : Data.List Data.Nat
// // ReturnPath n v l =?
//
// // ReturnPath
//   // (prev: Data.List (Data.Pair Data.U60 Data.U60))
//   // (i: Data.U60)
//   // (path: Data.List Data.U60)
//   // : Data.List Data.U60
//
// //   where
// //   update-prevs : ‚àÄ {n : ‚Ñï} ‚Üí vec[ S n ] (idx (S n)) ‚Üí idx (S n) ‚Üí list (idx (S n)) ‚Üí vec[ S n ] (idx (S n))
//   // update-prevs œÅ x [] = œÅ
// //   update-prevs {n} œÅ x (y ‚à∑ ys) = let i = (ùïö (idxval x) {(S n)} {{lemma3 (S n) x}})
// //                                   in update-prevs (œÅ #[ y ‚Ü¶ i ]) x ys
// // updatePrevs : (n : Nat) -> Vec (Idx (S n)) (S n) -> Idx (S n) -> List (Idx (S n)) -> Vec (Idx (S n)) (S n)
// // updatePrevs Z œÅ x [] = œÅ
// // updatePrevs (S k) œÅ x (y :: ys) = let i = idxVal x
// //                                   in updatePrevs k (updateAt y i œÅ) x ys
// //
UpdatePrevs 
  <n: Data.Nat> 
  (v: Data.Vector (Data.Fin (Data.Nat.succ n)) (Data.Nat.succ n)) 
  (i: Data.Fin (Data.Nat.succ n)) 
  (l: Data.List (Data.Fin (Data.Nat.succ n))) 
  : Data.Vector (Data.Fin (Data.Nat.succ n)) (Data.Nat.succ n)
UpdatePrevs v i Data.List.nil = v
// UpdatePrevs v i (Data.List.cons xs.h xs.t) =
  // let ix = Data.Fin.to_nat i
  // let xh = Data.Fin.to_nat xs.h
  // UpdatePrevs (Data.Vector.update_at ix xh v) i xs.t

Data.Vector.update_at
  <n: Data.Nat>
  (i: Data.Nat)
  (x: Data.Nat)
  (v: Data.Vector (Data.Fin (n)) (n))
  : Data.Vector (Data.Fin (i)) x
// Data.Vector.update_at n i Data.Nat.zero Data.Vector.nil = Data.Vector.nil
// Data.Vector.update_at n i Data.Nat.zero (Data.Vector.cons m f v) =

  

  // ?
  

  // ?
// Data.Vector.update_at n (Data.Nat.succ i) x v = ?
// Data.Vector.update_at n  Data.Nat.zero    x (Data.Vector.nil )       = Data.Vector.nil n
// Data.Vector.update_at n  Data.Nat.zero    x (Data.Vector.cons m f v)  = Data.Vector.cons n f v
// Data.Vector.update_at n (Data.Nat.succ i) x (Data.Vector.cons m f v)  = _
// Data.Vector.update_at n (Data.Nat.succ i) x (Data.Vector.nil)  = ?
// Data.Vector.update_at n (Data.Nat.succ m) x (Data.Vector.cons o f v)  = Data.Vector.cons n f (Data.Vector.update_at m x _)

#partial
Data.Vector.tail <n> <m: Data.Nat> (v: Data.Vector n m) : Data.Vector n (Data.Nat.pred m)
Data.Vector.tail n Data.Nat.zero v = v
// Data.Vector.tail n (Data.Nat.succ m) (Data.Vector.nil) = Impossivel
Data.Vector.tail n (Data.Nat.succ m) (Data.Vector.cons n_ f v) = v




// f1 = 0
// f s z = 0





// Update_prevs
//   <n: Data.Nat>
//   (v: Data.Vector (Data.U60) (Data.Nat.succ n))
//   (i: Data.U60)
//   (l: Data.List (Data.U60))
//   : Data.Vector  (Data.Nat.succ n)
// Update_prevs n v i Data.List.nil = v
// Update_prevs n v i (Data.List.cons xs.h xs.t) =
//   let ix = Data.U60.to_nat i
//   Update_prevs n (Data.Vector.update_at ix xs.h v) i xs.t
//

// Data.Vector.update_at
  // <n: Data.Nat>
  // (i: Data.Fin n)
  // (x: Data.Fin n)
  // (v: Data.Vector (Data.Fin n) (Data.List Data.Nat) )
  // : Data.Vector (Data.Fin n) n
// Data.Vector.update_at n Data.Fin.zero x v = v


//
// Data.Vector.update_at
  // <n: Data.Nat>
  // (i: Data.Nat)
  // (x: Data.U60)
  // (v: Data.Vector Data.U60 (Data.Nat.succ n))
  // : Data.Vector (Data.Nat.succ n)
// Data.Vector.update_at Data.Nat.zero i x v = Data.Vector.cons Data.Nat.zero x Data.Vector.nil
// Data.Vector.update_at Data.Nat.zero i x (Data.Vector.cons a v.h v.t) = Data.Vector.cons a x v.t
// Data.Vector.update_at (Data.Nat.succ n) i x Data.Vector.nil = ?
// Data.Vector.update_at (Data.Nat.succ n) i x (Data.Vector.cons a v.h v.t) =
//   let cond = Data.Nat.equal a i
//   let ind = Data.Vector.update_at n i x v.t
//   if cond {
//     Data.Vector.cons a x v.t
//   } else {
//     Data.Vector.cons a v.h ind
//   }
//
//
// // ?
// update-prevs : ‚àÄ {n : ‚Ñï} ‚Üí vec[ S n ] (idx (S n)) ‚Üí idx (S n) ‚Üí list (idx (S n)) ‚Üí vec[ S n ] (idx (S n))
// update-prevs œÅ x [] = œÅ
// update-prevs {n} œÅ x (y ‚à∑ ys) = let i = (ùïö (idxval x) {(S n)} {{lemma3 (S n) x}})
                                  // in update-prevs (œÅ #[ y ‚Ü¶ i ]) x ys



//
//
//
//
//
//
// // IdxVal (i: Data.U60) : Data.Nat
// // IdxVal i = Data.U60.to_nat i
//
// //   {- Terminates when queue is empty, that is, when all possible neighbors are seen -}
// //   bfs' :
// //     ‚àÄ {n}
// //     ‚Üí graph[ S n ]                         -- G: graph represented as adjacency matrix
// //     ‚Üí idx (S n) ‚Üí idx (S n)                -- Œπ‚ÇÄ: starting node ID, Œπ‚ÇÅ: target node ID
// //     ‚Üí list (idx (S n)) ‚Üí list (idx (S n))  -- Q: processing queue, œÉ: seen list
// //     ‚Üí vec[ S n ] (idx (S n))               -- œÅ: previous nodes list, default value is target
// //     ‚Üí vec[ S n ] (idx (S n))
Bfs_
  <n: Data.Nat>
  (g: Graph)
  (i1: Data.Fin (Data.Nat.succ n))
  (i2: Data.Fin (Data.Nat.succ n))
  (xs: Data.List Data.U60)
  (ts: Data.List Data.U60)
  (v: Data.Vector Data.U60 (Data.Nat.succ n))
  : Data.Vector (Data.Fin (Data.Nat.succ n)) (Data.Nat.succ n)
// Bfs_ g i1 i2 Data.List.nil ts v =
  // let idx = IdxVal i2
  // let ind = Data.Vector.update_at idx 0 v
  // ind
// Bfs_ g i1 i2 (Data.List.cons xs.h xs.t) ts v =
  // let xs  = Data.List.cons xs.h xs.t
  // let ind = Bfs_ g i1 i2 xs.t ts v
  // let ys  = FilterList_bfs (x => NotElem x xs.t) (Graph.get xs.h g)
  // match Data.List ys {
    // nil  => Bfs_ g i1 i2 xs.t ts v
    // cons => Bfs_ g i1 i2 (Data.List.concat xs.t ys) (Data.List.concat xs ys) (UpdatePrevs v xs.h ys)
  // }
//
// Nat.to_fin (n: Data.Nat)  : Data.Fin (Data.Nat.succ n)
// Nat.to_fin Data.Nat.zero  = Data.Fin.zero
// Nat.to_fin (Data.Nat.succ n) = Data.Fin.succ (Nat.to_fin n)


FilterList_bfs <t> (f: t -> Data.Bool) (l: Data.List t) : Data.List t
// FilterList_bfs t f Data.List.nil = Data.List.nil
// FilterList_bfs t f (Data.List.cons xs.h xs.t) =
  // if (f xs.h) {
    // Data.List.cons xs.h (FilterList_bfs f xs.t)
  // } else {
    // FilterList_bfs f xs.t
  // }
//
//
Graph.get (i: Data.U60) (g: Graph)                  : Data.List Data.U60
// Graph.get i Graph.nil                               = Data.List.nil
// Graph.get i (Graph.new (Data.List.nil))             = Data.List.nil
// Graph.get i (Graph.new (Data.List.cons xs.h xs.t))  =
  // let cond = Data.U60.to_bool (== (Data.Pair.fst xs.h) i)
  // let ind = Graph.get i (Graph.new xs.t)
  // if cond {
    // Data.Pair.snd xs.h
  // } else { ind }
//   // ?
//
//

Main {
  // Data.Vector.create 3n (x => Data.Vector.create 3n (y => (Data.Nat.succ y)))
  // Matrix.create 3n 3n 1 ((x: Data.U60) => (Data.U60.add 1 x))
  let lista = [1, 4, 2, 6, 3, 8, 33, 0, 9]
  // let grafo = Graph.new ()
  let g= Graph.new []
  // let g = Graph.new (Data.List.cons (Data.Pair.new 0 lista) (Data.List.nil))
  let g = Graph.addedge g (Data.Pair.new 0 1)
  let g = Graph.addedge g (Data.Pair.new 0 2)
  let g = Graph.addedge g (Data.Pair.new 1 2)
  let g = Graph.addedge g (Data.Pair.new 2 0)
  let g = Graph.addedge g (Data.Pair.new 2 3)
  let g = Graph.addedge g (Data.Pair.new 3 3)
  // (Bfs_traverse 2n g 1)
  // Graph.get 2 g
  // (Data.Vector.create 1n (x => (Data.Nat.to_u60 (Data.Nat.succ x))))
  // (Data.Vector.cons (Data.U60) 0n  (1) (Data.Vector.nil))
  g
}



// [ (1 [1, 2, 3, 4]) (2,) ()  ]








